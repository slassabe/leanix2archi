#!/usr/bin/env python
# coding: utf-8

'''
 Purpose :
   Dump LeanIx and convert output in various file format
   - Direct access LeanIX via LeanIX apitoken
'''

import requests
import time
import json

from leanixAuthor import create_credential
from leanIXConverterModels import Model, Element, Relationship, Reader
from customLog import get_default_logger

__author__ = "Serge LASSABE"
__copyright__ = "Copyright (C) 2023, Serge LASSABE"
__license__ = "agpl-3.0"
__version__ = "5.0.1"


def give_me_an_Id(label1, label2):
    return f"autogenerated-{label1}-{label2}"


class GraphQLReader(Reader):
    def __init__(self, base_API, workspace, token, model):
        super().__init__(model)
        self.base_API = base_API
        self.workspace = workspace
        self.access_token = create_credential(self.base_API, token)
        self.request_number = 0

    def populate(self, full_extract):
        # Manage FactSheets
        self.manage_element('Application')
        self.manage_element('DataObject')
        if (full_extract):
            self.manage_element('Project')
            self.manage_element('Process')
            self.manage_element('ITComponent')
            self.manage_element('TechnicalStack')
            self.manage_element('BusinessCapability')
            self.manage_element('UserGroup')
            # Then manage relations between FactSheets
            self.manage_relProjectToApplication()
            self.manage_relITComponentToApplication()
            self.manage_relApplicationToProcess()
            self.manage_relApplicationToBusinessCapability()
            self.manage_relApplicationToData()
            self.manage_relITComponentToTechnologyStack()
            self.manage_relApplicationToUserGroup()
            self.manage_relProjectToUserGroup()
        # The Serving relation type is not allowed between the System Software and Flow relation concepts
        # self.manage_relITComponentToInterface()

        # Last but not least...
        self.manage_interfaces()
        if (full_extract):
            self.manage_relInterfaceToData()

        # Manage fields
        self.manage_field(self.getFields('Application'), 'Application')
        self.manage_field(self.getFields('Interface'), 'Interface')

    def postGraphQlRequest(self, request, variables):
        self.request_number += 1

        url = f'https://{self.base_API}/services/pathfinder/v1/graphql'
        if variables:
            request_ctxt = {'query': request, 'variables': variables}
        else:
            request_ctxt = {'query': request}
        if False:
            time.sleep(0.1)  # to avoid http errors
        resp = requests.post(url, json=request_ctxt, headers={
                             'Authorization': 'Bearer {}'.format(self.access_token)})
        if resp.status_code != requests.codes.ok:
            self.logger.error(f'error for url : {url}')
            resp.raise_for_status()

        errors = resp.json().get('errors')
        if errors:
            self.logger.error(errors)
            exit(1)
        return resp

    def manage_element(self, type):
        query = '''
        query($atype: String, $cursor: String) {
          allFactSheets(first: 100, after: $cursor, filter: {facetFilters: [{facetKey: "FactSheetTypes", keys: [$atype]}]}) {
            pageInfo {
              hasNextPage
              endCursor }
            edges {
              node {
                displayName
                id
                description
                status}}}}
                '''

        loopin = True
        cursor = ""
        while loopin:
            variables = "{\"atype\": \"" + type + \
                "\", \"cursor\": \"" + cursor + "\"}"
            resp = self.postGraphQlRequest(query, variables)
            # Manage parent to children relations
            for nodes in resp.json()['data']['allFactSheets']['edges']:
                node = nodes['node']
                if node['status'] == 'ACTIVE':
                    elt = Element(
                        self.model, node['id'], type, node['displayName'], node['description'])
                else:
                    self.logger.info(
                        f'!!!!!!!!!!!!!!node {node["displayName"]} with status {node["status"]} discarded')
            pageinfo = resp.json()['data']['allFactSheets']['pageInfo']
            loopin = pageinfo['hasNextPage']
            cursor = pageinfo['endCursor']
            variables = "{\"atype\": \"" + type + \
                "\", \"cursor\": \"" + cursor + "\"}"
            # loopin = False  # uncomment for DEBUG purpose
        self.manage_children(type)

    def manage_children_aux(self, cursor, type):
        return f"""{{
          allFactSheets(first: 10, after: "{cursor}", filter: {{facetFilters: [{{facetKey: "FactSheetTypes", keys: ["{type}"]}}]}}) {{
                pageInfo {{
                  hasNextPage
                  endCursor}}
                edges {{
                  node {{
                    id
                    name
                    type
                    ... on {type} {{
                      relToChild {{
                        edges {{
                          node {{
                            id
                            factSheet {{
                                id
                                displayName
                                }}
                            }}}}}}
                  }}}}}}
            }}}}
        """

    def manage_children(self, type):
        loopin = True
        cursor = ''
        while loopin:
            resp = self.postGraphQlRequest(
                self.manage_children_aux(cursor, type), None)
            for edge in resp.json()['data']['allFactSheets']['edges']:
                parent_id = edge['node']['id']
                parent_name = edge['node']['name']
                for child in edge['node']['relToChild']['edges']:
                    rel_id = child['node']['id']
                    child_id = child['node']['factSheet']['id']
                    child_name = child['node']['factSheet']['displayName']
                    rel = Relationship(self.model, rel_id, 'Composition',
                                       '', 'parent-child relation', parent_id, child_id)
            pageinfo = resp.json()['data']['allFactSheets']['pageInfo']
            loopin = pageinfo['hasNextPage']
            cursor = pageinfo['endCursor']
            # loopin = False  # uncomment for DEBUG purpose

    def manage_interfaces(self):
        graphQL_request = """
            query($cursor: String) {
              allFactSheets(first: 100, after: $cursor, factSheetType: Interface) {
                pageInfo {
                  hasNextPage
                  endCursor }
                edges {
                  node {
                    name
                    type
                    id
                    description
                      ...on Interface {
                        relInterfaceToConsumerApplication {
                          edges {
                            node {
                              factSheet {
                                id
                                name
                              }}}}
                        relInterfaceToProviderApplication {
                          edges {
                            node {
                              factSheet {
                                id
                                name
                              }}}}}}}}}}
                              """

        loopin = True
        cursor = ""
        while loopin:
            variables = "{\"cursor\": \"" + cursor + "\"}"
            resp = self.postGraphQlRequest(graphQL_request, variables)
            #print(json.dumps(resp.json(), indent=4))
            edges = resp.json()['data']['allFactSheets']['edges']
            for nodes in edges:
                node = nodes['node']

                node_provider = node['relInterfaceToProviderApplication']['edges']
                if len(node_provider) == 1:
                    id_provider = node_provider[0]['node']['factSheet']['id']
                    name_provider = node_provider[0]['node']['factSheet']['name']
                elif len(node_provider) == 0:   # No provider
                    node_id = node['id']
                    node_name = node['name']
                    id_provider = give_me_an_Id('PROVIDER_UNDEF', node['id'])
                    self.model.warning(
                        2, f'interface(id : {node_id}, name : {node_name})', 'manage_interfaces')
                    interface = Element(
                        self.model, id_provider, node['type'], f"{self.model.interface_name_beautifier(node['name'])} (Fournisseur inconnu)", node['description'])
                    name_provider = 'Fournisseur inconnu'
                else:
                    self.error_number += 1
                    node_id = node['id']
                    node_name = node['name']
                    self.logger.debug(
                        f'Error found (0) - interface(id : {node_id}, name : {node_name}) - multi provider')
                    interface = Element(
                        self.model, node['id'], node['type'], f"ERROR: Multi provider for {node['name']}", node['description'])
                    for current_provider in node_provider:
                        id_provider = current_provider['node']['factSheet']['id']
                        name_provider = current_provider['node']['factSheet']['name']
                        rel = Relationship(self.model, give_me_an_Id(
                            node['id'], id_provider), 'Composition', '', 'Autogenerated relation', id_provider, node['id'])

                node_consumer = node['relInterfaceToConsumerApplication']['edges']
                nb_consumer = len(node_consumer)
                if nb_consumer == 0:
                    # interface without consumer
                    if len(node_provider) > 0:
                        # interface with providers
                        node_id = node['id']
                        node_name = node['name']
                        interface = Element(self.model, give_me_an_Id(
                            'CONSUMER_UNDEF', node['id']), node['type'], f"{self.model.interface_name_beautifier(node['name'])} ({node_provider[0]['node']['factSheet']['name']})", node['description'])
                        rel = Relationship(self.model, give_me_an_Id(
                            id_provider, node['id']), 'Composition', '', 'Autogenerated  relation', id_provider, interface.leanix_id)
                        self.model.warning(
                            4, f'interface(id : {node_id}, name : {node_name})', 'manage_interfaces')
                    else:
                        # interface without consumer and without provider... DISCARDED
                        self.model.warning(
                            3, f'interface(id : {node_id}, name : {node_name})', 'manage_interfaces')
                    # TO REMOVE: continue
                elif nb_consumer == 1:
                    # This is a flow
                    id_consumer = node_consumer[0]['node']['factSheet']['id']
                    self.model.check_flow_name(
                        node['name'], id_provider, id_consumer)
                    rel = Relationship(
                        self.model, node['id'], 'Flow', node['name'], node['description'], id_provider, id_consumer)
                else:
                    # This is an Interface
                    #  <provider app> --> <Interface> --> <consumers>
                    intf_id = node['id']
                    # Build a new id to resolve mutable objets (Flow <-> Interface)
                    new_intf_id = give_me_an_Id('INTF_', intf_id)
                    interface = Element(
                        self.model, new_intf_id, node['type'], f"{self.model.interface_name_beautifier(node['name'])} ({name_provider})", node['description'])
                    rel = Relationship(self.model, give_me_an_Id(
                        id_provider, intf_id), 'Composition', '', 'Autogenerated relation', id_provider, new_intf_id)
                    for current_consumer in node_consumer:
                        id_consumer = current_consumer['node']['factSheet']['id']
                        rel = Relationship(self.model, give_me_an_Id(
                            intf_id, id_consumer), 'Serving', '', 'Autogenerated relation', new_intf_id, id_consumer)

            pageinfo = resp.json()['data']['allFactSheets']['pageInfo']
            loopin = pageinfo['hasNextPage']
            cursor = pageinfo['endCursor']
            variables = "{\"cursor\": \"" + cursor + "\"}"
            #loopin = False

    def manage_GenericRel(self, object_type, relation_type_leanix, relation_type_archi):
        query = f""" {{
              allFactSheets(filter: {{facetFilters: [{{facetKey: "FactSheetTypes", keys: ["{object_type}"]}}]}}) {{
                    totalCount
                    edges {{
                      node {{
                        id
                        type
                        displayName
                        description
                        ... on {object_type} {{
                          {relation_type_leanix} {{
                            edges {{
                              node {{
                                id
                                type
                                factSheet {{
                                  id
                                  name
                                  type
                                  }}}}}}}}}}}}}}}}}}
        """
        variables = "{\"relType\": \"" + relation_type_leanix + "\"}"
        resp = self.postGraphQlRequest(query, variables)
        edges = resp.json()['data']['allFactSheets']['edges']
        for nodes in edges:
            node_p = nodes['node']

            rel_nodes = node_p[relation_type_leanix]['edges']

            for nodes in rel_nodes:
                node_r = nodes['node']
                id_rel = node_r['id']
                id_src = node_p['id']
                id_target = node_r['factSheet']['id']
                if (object_type == 'Interface'):
                    data_name = node_r["factSheet"]["name"]
                    rel_src = self.model.get_rel(id_src)
                    if (rel_src):
                        rel_src.set_tags(
                            self.model, 'LEANIX.DATA_OBJECT', data_name)
                    else:
                        self.logger.errodebugr(
                            f'!!! ERROR in manage_GenericRel (1) : cannot retrieve interface named {node_p["displayName"]}')
                else:
                    real = Relationship(
                        self.model, id_rel, relation_type_archi, None, None, id_src, id_target)

    def manage_relProjectToApplication(self):
        self.manage_GenericRel('Project', 'ITComponent',
                               'relITComponentToInterface', 'Association')

    def manage_relITComponentToApplication(self):
        self.manage_GenericRel(
            'ITComponent', 'relITComponentToApplication', 'Serving')

    def manage_relApplicationToProcess(self):
        self.manage_GenericRel(
            'Application', 'relApplicationToProcess', 'Realization')

    def manage_relApplicationToBusinessCapability(self):
        self.manage_GenericRel(
            'Application', 'relApplicationToBusinessCapability', 'Realization')

    def manage_relApplicationToData(self):
        self.manage_GenericRel(
            'Application', 'relApplicationToDataObject', 'Access')

    # TO BE REMOVED
    def manage_relInterfaceToData(self):
        self.manage_GenericRel('Interface', 'relInterfaceToDataObject', '')

    def manage_relITComponentToInterface(self):
        self.manage_GenericRel(
            'ITComponent', 'relITComponentToInterface', 'Serving')

    def manage_relProjectToApplication(self):
        self.manage_GenericRel(
            'Project', 'relProjectToApplication', 'Realization')

    def manage_relITComponentToTechnologyStack(self):
        self.manage_GenericRel(
            'ITComponent', 'relITComponentToTechnologyStack', 'Realization')

    def manage_relApplicationToUserGroup(self):
        self.manage_GenericRel(
            'Application', 'relApplicationToUserGroup', 'Influence')

    def manage_relProjectToUserGroup(self):
        self.manage_GenericRel('Project', 'relProjectToUserGroup', 'Influence')

    ##
    # Manage tags ans other tags
    # Implementation notes :
    #   - grahQL request is not adapted to access easily fields
    ##
    def formatURL(self, pageSize, cursor, type):
        self.request_number += 1
        if cursor:
            return f'https://{self.base_API}/services/pathfinder/v1/factSheets?type={type}&pageSize={pageSize}&cursor={cursor}&permissions=true'
        else:
            return f'https://{self.base_API}/services/pathfinder/v1/factSheets?type={type}&pageSize={pageSize}'

    def getFields(self, type):
        pageSize = 80
        sheetList = []
        count = 0
        cursor = None
        loopin = True

        while loopin:
            url = self.formatURL(pageSize, cursor, type)
            resp = requests.get(
                url, headers={'Authorization': 'Bearer {}'.format(self.access_token)})
            self.logger.debug("\n<<<< getFactSheets : status: {} - elapsed: {} - response: {}\n".format(
                resp.status_code, resp.elapsed.total_seconds(), json.dumps(resp.json(), indent=4)))
            subList = resp.json()['data']
            cursor = resp.json()['cursor']
            count += len(subList)
            sheetList = sheetList + subList
            self.logger.debug(">> total : {} - result length : {}".format(resp.json()
                                                                          ['total'], len(sheetList)))
            loopin = count < resp.json()['total']
            #loopin = False
        return sheetList

    def manage_field(self, values_list, type):
        for entry in values_list:
            id = entry.get('id')
            displayName = entry.get('displayName')
            type = entry.get('type')
            ##
            # Manage TAGS
            ##
            tags_list = entry.get('tags')
            for t in tags_list:
                tg = t.get('tagGroup')
                if tg:
                    k = tg.get('name')
                    v = t.get('name')
                    obj = None
                    if (type == 'Application'):
                        obj = self.model.get_elt(id)
                    elif (type == 'Interface'):
                        obj = self.model.get_rel(id)
                        if (not obj):
                            # Try to handle "mutable" interfaces
                            obj = self.model.get_elt(id)
                    if obj:
                        obj.set_tags(self.model, f'LEANIX.TAGS.{k}', v)
                    else:
                        self.logger.debug(
                            f'Error found (1) - {type} not found name : {displayName} -> Diagnose: Provider without Consumer interface')
            ##
            # Manage FIELDS / LIFECYCLE
            ##
            fields = entry.get('fields')
            for current_field in fields:
                name = current_field.get('name')
                if name == 'lifecycle':
                    '''
                    {
                        "name": "lifecycle",
                        "data": {
                            "type": "Lifecycle",
                            "phases": [
                                {
                                    "startDate": "2020-03-02",
                                    "phase": "plan"
                                }
                            ]
                        },
                        "dataType": null
                    },
                    '''
                    phases = current_field.get('data').get('phases')
                    for one_phase in phases:
                        p = one_phase.get('phase')
                        date = one_phase.get('startDate')
                        obj = None
                        if (type == 'Application'):
                            obj = self.model.get_elt(id)
                        elif (type == 'Interface'):
                            obj = self.model.get_rel(id)
                            if (not obj):
                                # Try to handle "mutable" interfaces
                                obj = self.model.get_elt(id)
                        if obj:
                            obj.set_tags(
                                self.model, f'LEANIX.FIELDS.LIFECYCLE.{p}', date)
                        else:
                            self.logger.debug(
                                f'Error found (2) - {type} not found name : {displayName} -> Diagnose: Provider without Consumer interface')
                ##
                # Manage FIELDS / EXTERNAL_ID
                ##
                elif name == 'externalId':
                    '''
                    {
                        "name": "externalId",
                        "data": {
                            "type": "ExternalId",
                            "externalId": "AJ",
                            "comment": null,
                            "status": "ACTIVE",
                            "externalUrl": null
                        },
                        "dataType": null
                    }
                    '''
                    xid = current_field.get('data').get('externalId')
                    if xid:
                        obj = None
                        if (type == 'Application'):
                            obj = self.model.get_elt(id)
                        elif (type == 'Interface'):
                            obj = self.model.get_rel(id)
                            if (not obj):
                                # Try to handle "mutable" interfaces
                                obj = self.model.get_elt(id)
                        if obj:
                            obj.set_tags(
                                self.model, f'LEANIX.FIELDS.EXTERNAL_ID', xid)
                        else:
                            self.logger.debug(
                                f'Error found (3) - {type} not found name : {displayName} -> Diagnose: Provider without Consumer interface')
